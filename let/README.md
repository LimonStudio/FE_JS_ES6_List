# let 数据类型说明符

记得在ES5中，甚至之前，JS都会被别人认为声明变量很乱
你既可以不用 `var` 这个关键字去声明变量，也可以使用

这就导致了一系列的问题
- 变量名相同，用var声明的变量几乎可以在任意的作用域可以反复利用
- 等等

所以在ES6中更加强调了一种规范，也就是引入了 `let` 和 `const` 这两个数据类型说明符，两者都实现了在其所在的作用域也就是代码块，其申明变量的有效性。

## let

### 基本用法

```js
{
  let a = 10
  var b = 1
}
a // ReferenceError: a is not defined
b // 1
```

这种写法就与其他编程语言十分相同了，上面代码中 `let` 和 `var` 声明的变量，只有 let 声明的 `b` 可以在括号外使用，这说明，`let` 的确将变量限制在了这个块作用域内，不让它四处放荡。

写到这里，不难会想起ES5之前的作用域hell，所以这里展示出来，你可能不会这么写，但是这样写对于新手来说完全没有任何问题，但是这里就隐藏着一个作用域的hell

[demo1.html](./demo1.html)

可以将这个文件用浏览器打开，先看看源代码，再看看结果是否跟你想得有所区别。
如果你是JS新手，你肯定有疑问，这JS有问题吧。
的确这是JS那时的问题，不过还是有办法解决的，但是这里要讲的就是作用域的重要性。

好在ES6引入了 `let` 让这个问题不会再次发生，只要你使用 `let` 去申明变量

其实为了示例代码能在 `nodejs` 上运行，以上代码也可以这样来写

```js
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
```
可以通过调试，你就会发现，以上的代码中，a中所有子项如a[0]都是指向
```js
function () {
  console.log(i)
}
```
而就因为i是var的申明，所以当你调用a[6]或者其中的任意一个值，i最后是10，没错它一直存在着，所以打印出来的是10
然而，如果你使用 `let` 去申明i这个变量
```js
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
```
在这里你可能会问，为什么不会报错，像之前一样，因为它没有在作用域中，这里又会考虑到闭包的问题，关联到函数中Clouser的一系列的问题。这么简单说吧，如果用 `var` 申明的变量，在函数赋值时，用到的变量会放在函数的Clouser里，不过它是一个全局变量，所以会一直变，而当用到 `let` 去申明一个变量时，函数变量不会将其放在 Clouser 中，而是放在block里，也就自己的一个作用域里，因为不放在里面，一旦引用就会报错，所以这里会记住它。

## 不存在变量提升与暂时性死区

这都是块作用域带来的影响，这里不再详述，可以参照[阮一峰老师的ES6不存在变量提升](http://es6.ruanyifeng.com/#docs/let#不存在变量提升)

## 不存在变量提升

`let` 不允许在相同作用域内，重复声明同一个变量。
```js
// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
```
因此，不能在函数内部重新声明参数。
```js
function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
```
